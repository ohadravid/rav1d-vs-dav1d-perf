use std::{hint::black_box, mem};

#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum BlockSize {
    Bs128x128 = 0,
    Bs128x64 = 1,
    Bs64x128 = 2,
    Bs64x64 = 3,
    Bs64x32 = 4,
    Bs64x16 = 5,
    Bs32x64 = 6,
    Bs32x32 = 7,
    Bs32x16 = 8,
    Bs32x8 = 9,
    Bs16x64 = 10,
    Bs16x32 = 11,
    Bs16x16 = 12,
    Bs16x8 = 13,
    Bs16x4 = 14,
    Bs8x32 = 15,
    Bs8x16 = 16,
    Bs8x8 = 17,
    Bs8x4 = 18,
    Bs4x16 = 19,
    Bs4x8 = 20,
    Bs4x4 = 21,
}

/// Note that this is legitimately [`Copy`]
/// (unlike other transpiled types that are [`Copy`] due to being from C).
/// This is needed because [`mv`] is used within packed structs like [`refmvs_block`],
/// meaning a reference to [`mv`] cannot always be take,
/// which includes `&self` methods, including autogenerated ones like [`PartialEq::eq`].
///
/// [`refmvs_block`]: crate::src::refmvs::refmvs_block
#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
#[repr(C)]
pub struct Mv {
    pub y: i16,
    pub x: i16,
}

impl Mv {
    pub const ZERO: Self = Self { y: 0, x: 0 };

    pub const INVALID: Self = Self {
        y: i16::MIN,
        x: i16::MIN,
    };

    pub fn is_invalid(self) -> bool {
        self == Self::INVALID
    }

    #[allow(dead_code)]
    pub fn is_valid(self) -> bool {
        !self.is_invalid()
    }
}

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
// In C, this is packed and is 2 bytes.
// In Rust, being packed and aligned is tricky
#[repr(C, align(2))]
pub struct RefMvsRefPair {
    pub r#ref: [i8; 2],
}
const _: () = assert!(mem::size_of::<RefMvsRefPair>() == 2);

impl From<[i8; 2]> for RefMvsRefPair {
    fn from(from: [i8; 2]) -> Self {
        RefMvsRefPair { r#ref: from }
    }
}

#[derive(Clone, Copy, Default, PartialEq, Eq, Debug)]
#[repr(C)]
pub struct RefMvsMvPair {
    pub mv: [Mv; 2],
}
const _: () = assert!(mem::size_of::<RefMvsMvPair>() == 8);

#[derive(Clone, Copy, Debug)]
// In C, this is packed and is 12 bytes.
// In Rust, being packed and aligned is tricky
#[repr(C, align(4))]
pub struct RefMvsBlock {
    pub mv: RefMvsMvPair,
    pub r#ref: RefMvsRefPair,
    pub bs: BlockSize,
    pub mf: u8,
}
const _: () = assert!(mem::size_of::<RefMvsBlock>() == 12);

#[derive(Copy, Clone, Default, Debug)]
#[repr(C)]
pub struct RefMvsCandidate {
    pub mv: RefMvsMvPair,
    pub weight: i32,
}

fn add_spatial_candidate(
    mvstack: &mut [RefMvsCandidate],
    cnt: &mut usize,
    weight: i32,
    b: RefMvsBlock,
    r#ref: RefMvsRefPair,
    gmv: &[Mv; 2],
    have_newmv_match: &mut i32,
    have_refmv_match: &mut i32,
) {
    if b.mv.mv[0].is_invalid() {
        // intra block, no intrabc
        return;
    }

    let mf_odd = b.mf & 1 != 0;
    if r#ref.r#ref[1] == -1 {
        for n in 0..2 {
            if b.r#ref.r#ref[n] == r#ref.r#ref[0] {
                let cand_mv = if mf_odd && gmv[0] != Mv::INVALID {
                    gmv[0]
                } else {
                    b.mv.mv[n]
                };

                *have_refmv_match = 1;
                *have_newmv_match |= b.mf as i32 >> 1;

                let last = *cnt;
                for cand in &mut mvstack[..last] {
                    if cand.mv.mv[0] == cand_mv {
                        cand.weight += weight;
                        return;
                    }
                }

                if last < 8 {
                    let cand = &mut mvstack[last];
                    cand.mv.mv[0] = cand_mv;
                    cand.weight = weight;
                    *cnt = last + 1;
                }
                return;
            }
        }
    } else if b.r#ref == r#ref {
        let cand_mv = RefMvsMvPair {
            mv: [
                if mf_odd && gmv[0] != Mv::INVALID {
                    gmv[0]
                } else {
                    b.mv.mv[0]
                },
                if mf_odd && gmv[1] != Mv::INVALID {
                    gmv[1]
                } else {
                    b.mv.mv[1]
                },
            ],
        };

        *have_refmv_match = 1;
        *have_newmv_match |= b.mf as i32 >> 1;

        let last = *cnt;
        for cand in &mut mvstack[..last] {
            if cand.mv == cand_mv {
                cand.weight += weight;
                return;
            }
        }

        if last < 8 {
            let cand = &mut mvstack[last];
            cand.mv = cand_mv;
            cand.weight = weight;
            *cnt = last + 1;
        }
    }
}

fn sample() {
    let mut mvstack = [
        RefMvsCandidate {
            mv: RefMvsMvPair {
                mv: [Mv { y: 0, x: 0 }, Mv { y: 0, x: 0 }],
            },
            weight: 0,
        },
        RefMvsCandidate {
            mv: RefMvsMvPair {
                mv: [Mv { y: 0, x: 0 }, Mv { y: 0, x: 0 }],
            },
            weight: 0,
        },
        RefMvsCandidate {
            mv: RefMvsMvPair {
                mv: [Mv { y: 0, x: 0 }, Mv { y: 0, x: 0 }],
            },
            weight: 0,
        },
        RefMvsCandidate {
            mv: RefMvsMvPair {
                mv: [Mv { y: 0, x: 0 }, Mv { y: 0, x: 0 }],
            },
            weight: 0,
        },
        RefMvsCandidate {
            mv: RefMvsMvPair {
                mv: [Mv { y: 0, x: 0 }, Mv { y: 0, x: 0 }],
            },
            weight: 0,
        },
        RefMvsCandidate {
            mv: RefMvsMvPair {
                mv: [Mv { y: 0, x: 0 }, Mv { y: 0, x: 0 }],
            },
            weight: 0,
        },
        RefMvsCandidate {
            mv: RefMvsMvPair {
                mv: [Mv { y: 0, x: 0 }, Mv { y: 0, x: 0 }],
            },
            weight: 0,
        },
        RefMvsCandidate {
            mv: RefMvsMvPair {
                mv: [Mv { y: 0, x: 0 }, Mv { y: 0, x: 0 }],
            },
            weight: 0,
        },
    ];
    let mut cnt = 0;
    let weight = 192;
    let b = RefMvsBlock {
        mv: RefMvsMvPair {
            mv: [Mv { y: 0, x: 0 }, Mv { y: 0, x: 0 }],
        },
        r#ref: RefMvsRefPair { r#ref: [1, -1] },
        bs: BlockSize::Bs128x128,
        mf: 0,
    };
    let r#ref = RefMvsRefPair { r#ref: [1, -1] };
    let gmv = [
        Mv {
            y: -32768,
            x: -32768,
        },
        Mv { y: 0, x: 0 },
    ];
    let mut have_newmv_match = 0;
    let mut have_refmv_match = 0;

    add_spatial_candidate(
        &mut mvstack,
        &mut cnt,
        weight,
        b,
        r#ref,
        &gmv,
        &mut have_newmv_match,
        &mut have_refmv_match,
    );

    black_box(mvstack);
}

fn main() {
    for _ in 0..500000000i64 {
        sample();
    }
}
